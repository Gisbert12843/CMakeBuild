#!/usr/bin/env python3
# build.py
import os
import json
import platform
import sys
import time
import shutil
import subprocess

# Get the directory where this script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
# ../lib
lib_dir = os.path.abspath(os.path.join(script_dir, "..", "lib"))

python_executable = "python3"
cmakelist_patcher_script = os.path.join(lib_dir, "__cmakelist_patcher")
Config_File = "build.conf"
Template_Config_File = os.path.join(lib_dir, "build.conf.template")
Template_CMakeLists_File = os.path.join(lib_dir, "CMakeLists.txt.template")
CMakeFile = "CMakeLists.txt"


def parse_config_topics(file_content: str) -> dict:
    """
    Parses a simple indented text configuration into a dictionary.
    Same logic as in __cmakelist_patcher.
    """
    import collections
    parsed_data = collections.OrderedDict()
    current_topic = None

    for line_num, line in enumerate(file_content.splitlines(), 1):
        stripped_line = line.strip()

        if not stripped_line or stripped_line.startswith("#"):
            continue

        if not line[0].isspace():
            current_topic = stripped_line
            if current_topic in parsed_data:
                raise ValueError(
                    f"Configuration Error: Duplicate topic '{current_topic}' found on line {line_num}."
                )
            parsed_data[current_topic] = []
        else:
            if not current_topic:
                raise ValueError(
                    f"Configuration Error: Found an indented child '{stripped_line}' on line {line_num} before any topic was defined."
                )
            parsed_data[current_topic].append(stripped_line)

    return dict(parsed_data)


def get_toolchain_config() -> tuple:
    """
    Reads Toolchain and ToolchainPath from build.conf.
    Returns (toolchain_name, toolchain_path) tuple.
    toolchain_path may be None if not specified.
    """
    if not os.path.exists(Config_File):
        return (None, None)
    
    try:
        with open(Config_File, "r") as f:
            config = parse_config_topics(f.read())
    except Exception as e:
        print_error(f"Error parsing {Config_File}: {e}")
        return (None, None)
    
    toolchain = None
    toolchain_path = None
    
    if "Toolchain" in config and config["Toolchain"]:
        toolchain = config["Toolchain"][0]
    
    if "ToolchainPath" in config and config["ToolchainPath"]:
        toolchain_path = config["ToolchainPath"][0]
    
    return (toolchain, toolchain_path)


def get_language_standards() -> tuple:
    """
    Reads CppVersion and CVersion from build.conf.
    Returns (cpp_version, c_version) tuple.
    Values may be None if not specified.
    """
    if not os.path.exists(Config_File):
        return (None, None)
    
    try:
        with open(Config_File, "r") as f:
            config = parse_config_topics(f.read())
    except Exception as e:
        print_error(f"Error parsing {Config_File}: {e}")
        return (None, None)
    
    cpp_version = None
    c_version = None
    
    if "CppVersion" in config and config["CppVersion"]:
        cpp_version = config["CppVersion"][0]
    
    if "CVersion" in config and config["CVersion"]:
        c_version = config["CVersion"][0]
    
    return (cpp_version, c_version)


def find_compiler(toolchain: str, toolchain_path: str | None = None) -> tuple:
    """
    Finds the C and C++ compiler executables for a given toolchain.
    
    Args:
        toolchain: The toolchain name (e.g., 'gcc', 'clang', 'gcc-arm-none-eabi')
        toolchain_path: Optional path to the toolchain bin directory
    
    Returns:
        Tuple of (c_compiler, cxx_compiler) absolute paths, or (None, None) if not found.
    """
    # Common patterns for different toolchains
    if toolchain.startswith("gcc") or toolchain.endswith("-gcc"):
        # For cross-compilers like gcc-arm-none-eabi, arm-none-eabi-gcc, etc.
        if "-" in toolchain:
            # Try both formats: toolchain-gcc and gcc-toolchain
            prefix = toolchain.replace("-gcc", "").replace("gcc-", "")
            c_names = [f"{prefix}-gcc", f"{toolchain}-gcc", toolchain]
            cxx_names = [f"{prefix}-g++", f"{toolchain}-g++", toolchain.replace("gcc", "g++")]
        else:
            c_names = ["gcc"]
            cxx_names = ["g++"]
    elif toolchain.startswith("clang") or toolchain.endswith("-clang"):
        if "-" in toolchain:
            prefix = toolchain.replace("-clang", "").replace("clang-", "")
            c_names = [f"{prefix}-clang", f"clang-{prefix}", toolchain]
            cxx_names = [f"{prefix}-clang++", f"clang++-{prefix}", toolchain.replace("clang", "clang++")]
        else:
            c_names = ["clang"]
            cxx_names = ["clang++"]
    else:
        # Generic: assume it's the C compiler name directly
        c_names = [toolchain]
        # Try common C++ suffixes
        if toolchain.endswith("cc"):
            cxx_names = [toolchain[:-2] + "++", toolchain.replace("cc", "c++")]
        elif toolchain.endswith("gcc"):
            cxx_names = [toolchain.replace("gcc", "g++")]
        else:
            cxx_names = [toolchain + "++", toolchain]
    
    def find_executable(names, search_path=None):
        for name in names:
            if search_path:
                full_path = os.path.join(search_path, name)
                if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
                    return full_path
            # Also check PATH
            result = shutil.which(name, path=search_path)
            if result:
                return result
        return None
    
    c_compiler = find_executable(c_names, toolchain_path)
    cxx_compiler = find_executable(cxx_names, toolchain_path)
    
    return (c_compiler, cxx_compiler)


def print_error(message):
    print(f"\033[91m{message}\033[0m")


def error(message) -> str:
    return f"\033[91m{message}\033[0m"


def delete_folder(folder_path):
    if os.path.exists(folder_path) and os.path.isdir(folder_path):
        shutil.rmtree(folder_path)
        print(f"Deleted folder: {folder_path}")
    else:
        print(f"Folder not found: {folder_path}")


# obtains name from the CMakeFile after it has been patched
def get_target_executable_name() -> str:
    if not os.path.exists(CMakeFile):
        print(f"{CMakeFile} does not exist.")
        return ""

    with open(CMakeFile, "r") as file:
        for line in file:
            if line.strip().startswith("set(CMAKE_PROJECT_NAME "):
                # Extract the word until the closing parenthesis
                target_name = (
                    line.strip().split("set(CMAKE_PROJECT_NAME ")[1].split(")")[0]
                )
                return target_name
    print(f"TARGET_EXECUTABLE not found in {CMakeFile}.")
    return ""


def build_project():
    # Use CMake build system
    # Read toolchain configuration from build.conf
    toolchain, toolchain_path = get_toolchain_config()
    cpp_version, c_version = get_language_standards()
    
    c_compiler = None
    cxx_compiler = None
    
    if toolchain:
        c_compiler, cxx_compiler = find_compiler(toolchain, toolchain_path)
        if not c_compiler and not cxx_compiler:
            print_error(f"Could not find compiler for toolchain '{toolchain}'")
            if toolchain_path:
                print_error(f"  Searched in: {toolchain_path}")
            print_error("  Also searched in PATH")
            return False
    
    # Build the configure command
    configure_cmd = "cmake -S . -B build --fresh"
    
    if c_compiler or cxx_compiler:
        if c_compiler:
            configure_cmd += f" -DCMAKE_C_COMPILER={c_compiler}"
        if cxx_compiler:
            configure_cmd += f" -DCMAKE_CXX_COMPILER={cxx_compiler}"
        print(f"Using toolchain:")
        if c_compiler:
            print(f"  C Compiler: {c_compiler}")
        if cxx_compiler:
            print(f"  C++ Compiler: {cxx_compiler}")
    else:
        print("No toolchain configured, using system default compiler.")
    
    # Add language standard flags
    if cpp_version:
        configure_cmd += f" -DCMAKE_CXX_STANDARD={cpp_version}"
        print(f"C++ Standard: C++{cpp_version}")
    if c_version:
        configure_cmd += f" -DCMAKE_C_STANDARD={c_version}"
        print(f"C Standard: C{c_version}")
    
    build_cmd = "cmake --build build"

    print("Configuring CMake project...")
    result = os.system(configure_cmd)
    if result != 0:
        print("CMake configuration failed!")
        return False

    print("Building project...")
    result = os.system(build_cmd)
    if result != 0:
        print("Build failed!")
        return False

    print("Build completed successfully!")
    return True


def clean_project():
    # Clean CMake build directory
    delete_folder("build")
    print("Cleaned build directory")


def full_clean_project():
    # Clean everything that can be regenerated
    delete_folder("build")
    delete_folder("cmake")
    if os.path.exists("CMakeLists.txt"):
        os.remove("CMakeLists.txt")
    if os.path.exists("CMakePresets.json"):
        os.remove("CMakePresets.json")
    if os.path.exists("CMakeUserPresets.json"):
        os.remove("CMakeUserPresets.json")
    if os.path.exists("CMakeCache.txt"):
        os.remove("CMakeCache.txt")

    for file in os.listdir("."):
        if (
            file.endswith(".h")
            or file.endswith(".s")
            or file.endswith(".c")
            or file.endswith(".ld")
            or file.endswith(".mxproject")
        ):
            print(f"Removing file: {file}")
            os.remove(file)

def generate_config_file() -> None:
    with open(Config_File, "w") as f:
        if os.path.exists(Template_Config_File):
            with open(Template_Config_File, "r") as template_file:
                f.write(template_file.read())
            print(f"Generated {Config_File} from template.")
        else:
            print_error(f"Template config file not found: {Template_Config_File}")
            print_error(f"Please reinstall cmakebuild!")
            sys.exit(1)


def generate_cmake_file(force: bool = False) -> bool:
    """Generate a starting CMakeLists.txt file from template.
    
    Args:
        force: If True, overwrite existing CMakeLists.txt file.
        
    Returns:
        True if file was generated, False otherwise.
    """
    if os.path.exists(CMakeFile) and not force:
        print(f"{CMakeFile} already exists. Use 'generate_cmake --force' to overwrite.")
        return False
    
    if not os.path.exists(Template_CMakeLists_File):
        print_error(f"Template CMakeLists.txt file not found: {Template_CMakeLists_File}")
        print_error(f"Please reinstall cmakebuild!")
        return False
    
    with open(Template_CMakeLists_File, "r") as template_file:
        template_content = template_file.read()
    
    with open(CMakeFile, "w") as f:
        f.write(template_content)
    
    print(f"Generated {CMakeFile} from template.")
    print(f"You can now edit {Config_File} and run 'cmakebuild update' to apply your configuration.")
    return True


def patch_project():
        

    result = os.system(
        f"{python_executable} {cmakelist_patcher_script} --cmake-file ./CMakeLists.txt"
    )
    print(f"Return code: {result >> 8}")  # os.system returns exit code << 8
    
    # Show toolchain configuration info
    toolchain, toolchain_path = get_toolchain_config()
    if toolchain:
        print(f"\nToolchain configured: {toolchain}")
        if toolchain_path:
            print(f"Toolchain path: {toolchain_path}")
        
        c_compiler, cxx_compiler = find_compiler(toolchain, toolchain_path)
        
        if c_compiler or cxx_compiler:
            print("Resolved compilers:")
            if c_compiler:
                print(f"  C Compiler: {c_compiler}")
            if cxx_compiler:
                print(f"  C++ Compiler: {cxx_compiler}")
        else:
            print_error(f"Warning: Could not find compiler for toolchain '{toolchain}'")
            if toolchain_path:
                print_error(f"  Searched in: {toolchain_path}")
            print_error("  Also searched in PATH")
            print_error("  Please check your Toolchain and ToolchainPath settings in build.conf")
    
    # Update VS Code settings if c_cpp_properties.json exists
    update_vscode_include_paths()
    update_vscode_language_standards()


def un_patch_cmakefile():
    result = os.system(
        f"{python_executable} {cmakelist_patcher_script} --cmake-file ./CMakeLists.txt --restore"
    )
    print(f"Return code: {result >> 8}")


def update_vscode_intellisense(create_file=False):
    # find or create and patch .vscode/c_cpp_properties.json by adding "compileCommands": ["${workspaceFolder}/build/compile_commands.json"]
    path = ".vscode/c_cpp_properties.json"
    new_path = "${workspaceFolder}/build/compile_commands.json"

    if not os.path.exists(path):
        if create_file:
            os.makedirs(".vscode", exist_ok=True)
            default_config = {
                "configurations": [{"name": "Linux", "compileCommands": [new_path]}],
                "version": 4,
            }
            with open(path, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            print("Created .vscode/c_cpp_properties.json with compileCommands")
            return
        else:
            return  # File doesn't exist and we shouldn't create it

    print("Updating .vscode/c_cpp_properties.json for Intellisense...")

    with open(path, "r+", encoding="utf-8") as f:
        try:
            data = json.load(f)
        except json.JSONDecodeError:
            print("Invalid or empty JSON file, creating new configuration...")
            data = {"configurations": [], "version": 4}

        # Ensure configurations key exists
        if "configurations" not in data:
            data["configurations"] = []

        if len(data["configurations"]) == 0:
            data["configurations"].append(
                {"name": "Linux", "compileCommands": [new_path]}
            )
            modified = True
        else:
            modified = False
            for cfg in data["configurations"]:
                if "compileCommands" not in cfg:
                    cfg["compileCommands"] = [new_path]
                    modified = True
                else:
                    if not isinstance(cfg["compileCommands"], list):
                        cfg["compileCommands"] = [str(cfg["compileCommands"])]
                        modified = True

                    if new_path not in cfg["compileCommands"]:
                        cfg["compileCommands"].append(new_path)
                        modified = True

        if modified:
            f.seek(0)
            json.dump(data, f, indent=4)
            f.truncate()
            print("Patched existing c_cpp_properties.json")
        else:
            print("c_cpp_properties.json already patched")


def update_vscode_language_standards():
    """
    Updates the cStandard and cppStandard in .vscode/c_cpp_properties.json based on build.conf.
    Only updates if the file already exists.
    """
    path = ".vscode/c_cpp_properties.json"
    
    if not os.path.exists(path):
        return  # Only update if file exists
    
    cpp_version, c_version = get_language_standards()
    
    if not cpp_version and not c_version:
        return  # No language standards configured
    
    print("Updating .vscode/c_cpp_properties.json with language standards...")
    
    try:
        with open(path, "r+", encoding="utf-8") as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                print_error("Invalid JSON in c_cpp_properties.json, skipping language standards update")
                return
            
            if "configurations" not in data or len(data["configurations"]) == 0:
                return
            
            modified = False
            for cfg in data["configurations"]:
                if cpp_version:
                    # Convert numeric version to c_cpp_properties format (e.g., "17" -> "c++17")
                    cpp_std = f"c++{cpp_version}"
                    if cfg.get("cppStandard") != cpp_std:
                        cfg["cppStandard"] = cpp_std
                        modified = True
                
                if c_version:
                    # Convert numeric version to c_cpp_properties format (e.g., "11" -> "c11")
                    c_std = f"c{c_version}"
                    if cfg.get("cStandard") != c_std:
                        cfg["cStandard"] = c_std
                        modified = True
            
            if modified:
                f.seek(0)
                json.dump(data, f, indent=4)
                f.truncate()
                standards_msg = []
                if cpp_version:
                    standards_msg.append(f"C++{cpp_version}")
                if c_version:
                    standards_msg.append(f"C{c_version}")
                print(f"Updated language standards: {', '.join(standards_msg)}")
            else:
                print("Language standards already up to date")
    
    except Exception as e:
        print_error(f"Error updating c_cpp_properties.json: {e}")


def update_vscode_include_paths():
    """
    Updates the includePath in .vscode/c_cpp_properties.json with folders from build.conf.
    Includes both IncludeFolders and library paths from Libraries.
    Only updates if the file already exists.
    """
    path = ".vscode/c_cpp_properties.json"
    
    if not os.path.exists(path):
        print("No .vscode/c_cpp_properties.json found, skipping include path update.")
        return  # Only update if file exists
    
    if not os.path.exists(Config_File):
        print(f"No {Config_File} found, skipping include path update.")
        return  # No config file to read from
    
    # Read config from build.conf
    try:
        with open(Config_File, "r") as f:
            config = parse_config_topics(f.read())
    except Exception as e:
        print_error(f"Error parsing {Config_File}: {e}")
        return
    
    # Start with workspace folder
    vscode_include_paths = ["${workspaceFolder}"]
    
    # Add include folders
    include_folders = config.get("IncludeFolders", [])
    for folder in include_folders:
        if folder.startswith("#"):
            continue
        vscode_include_paths.append(f"${{workspaceFolder}}/{folder}")
    
    # Add library paths (Libraries format: "libName path/to/lib")
    libraries = config.get("Libraries", [])
    for lib_entry in libraries:
        if lib_entry.startswith("#"):
            continue
        parts = lib_entry.split(" ", 1)
        if len(parts) == 2:
            lib_path = parts[1]
            # Add the library path itself
            if lib_path.startswith("/"):
                # Absolute path
                vscode_include_paths.append(lib_path)
            else:
                # Relative path
                vscode_include_paths.append(f"${{workspaceFolder}}/{lib_path}")
            # Also add common include subdirectories if they might exist
            for subdir in ["include", "inc", "src", "Include", "Inc", "Src"]:
                if lib_path.startswith("/"):
                    vscode_include_paths.append(f"{lib_path}/{subdir}")
                else:
                    vscode_include_paths.append(f"${{workspaceFolder}}/{lib_path}/{subdir}")
    
    if len(vscode_include_paths) <= 1:
        print("No include paths configured in build.conf.")
        return  # Only the default path, no actual folders
    
    print("Updating .vscode/c_cpp_properties.json with include paths...")
    
    try:
        with open(path, "r+", encoding="utf-8") as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                print_error("Invalid JSON in c_cpp_properties.json, skipping include path update")
                return
            
            if "configurations" not in data or len(data["configurations"]) == 0:
                return
            
            modified = False
            for cfg in data["configurations"]:
                current_paths = cfg.get("includePath", [])
                
                # Check if update is needed
                if set(current_paths) != set(vscode_include_paths):
                    cfg["includePath"] = vscode_include_paths
                    modified = True
            
            if modified:
                f.seek(0)
                json.dump(data, f, indent=4)
                f.truncate()
                print(f"Updated includePath with: {', '.join(include_folders)}")
            else:
                print("includePath already up to date")
    
    except Exception as e:
        print_error(f"Error updating c_cpp_properties.json: {e}")


def update_cmakefile():
    print("Restoring CMakeLists.txt to defaults...")
    un_patch_cmakefile()
    print("Patching CMakeLists.txt...")
    patch_project()


def launch_project():
    target_name = get_target_executable_name()
    if not target_name:
        print_error("Could not determine target executable name.")
        return

    executable_path = os.path.join("build", target_name)
    
    if not os.path.exists(executable_path):
        print_error(f"Executable not found at {executable_path}")
        print_error("Please build the project first.")
        return

    print(f"Launching {executable_path}...")
    os.system(executable_path)


# fmt: off

def print_usage():
    print("Usage: cmakebuild [command]")
    print("Commands:")
    print("  all                          - Update, build and flash project (default)")
    print("  init                         - Initialize project (config, cmake, vscode)")
    print("  generate_cmake               - Generate a starting CMakeLists.txt file from template")
    print("  build                        - Attempt to build project only")
    print("  launch                       - Run the executable located in the build folder")
    print("  clean                        - Clean build folder")
    print("  update                       - Restore CMakeLists.txt to defaults then patch it")
    print("  restore                      - Restore CMakeLists.txt to defaults")
    print("  enable_vscode_intellisense   - Generate .vscode/c_cpp_properties.json for Intellisense")

# fmt: on


if __name__ == "__main__":
    start_time = time.time()

    # detect linux os
    detected_os = platform.system()
    if not detected_os == "Linux":
        print("This script is intended to run on Linux systems.")
        print("Detected OS:", detected_os)
        sys.exit(1)

    # Get command line argument
    command = sys.argv[1] if len(sys.argv) > 1 else "help"

    if command == "all":
        update_cmakefile()
        if build_project():
            print("Build succeeded.\nStarting Executible.")
            launch_project()
            sys.exit(0)
        else:
            print("Build failed, not flashing.")
            delete_folder("build")
            sys.exit(1)
    elif command == "init":
        if os.path.exists(Config_File):
            print(f"{Config_File} already exists.")
        else:
            generate_config_file()
        
        if not os.path.exists(CMakeFile):
            generate_cmake_file()

        update_vscode_intellisense(create_file=False)

    elif command == "generate_cmake":
        force = "--force" in sys.argv
        if not generate_cmake_file(force):
            sys.exit(1)

    elif command == "build":
        if build_project():
            print("Build succeeded.")
            sys.exit(0)
        else:
            print("Build failed!!")
            sys.exit(1)
            
    elif command == "launch":
        launch_project()

    elif command == "clean":
        clean_project()

    elif command == "update":
        update_cmakefile()
        
    elif command == "restore":
        un_patch_cmakefile()

    elif command == "enable_vscode_intellisense":
        update_vscode_intellisense(True)

    elif command == "help" or command == "--help" or command == "-h":
        print_usage()
        sys.exit(0)

    else:
        print(f"Unknown command: {command}")
        print_usage()
        sys.exit(1)

    end_time = time.time()
    print(f"Operation completed in {end_time - start_time:.2f} seconds.")
